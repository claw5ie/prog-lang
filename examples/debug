val00 := 0;

// TODO: allow to assign constants to enumerators, e.g. "A = 2 + 2".
Baz := enum
{
  A,
  B,
  C,
}

Faz := union
{
  x: []int, // Also reject.
  y: *bool,
}

Foo := struct
{
  x: int,
  y: bool,
  z: Baz,
}

Bar := struct
{
  foo: Foo,
}

bar := proc(aa: struct { x: int }) // reject.
{
  while true break;
  do continue; while false;

  x: Foo = .{ x = 2, y = false };
  x = .{ x = 2 };
  x.x.foo = 2;
  x.z = .A;

  y: *Foo = &x;
  z: **Foo = null;
  x.* = 42;
  z.  *.*;

  b: [3]int;
  a: [2][]int = .{ .{ 0, 1, 2 }, b };
  c: []int; // Needs to be rejected. Can't infere the type.
  d := .{ .{ 1, 2, 3 } };
  a[0] = .{ 2, 3, 4 };
  a[0][1] = 42;

  e: bool = cast1(2);
  f := cast2(bool, 2);

  if false then {} else {}

  val00 = val00 + 42;
  return;
}

main := proc() -> void
{
  val0 := -2 + 2;
  val1: int = 2;
  val2: bool = false;

  val0 = 4;
  val3: proc() = main;
  val3();

  if !true || false && true
    ;
  else
    ;

  val4: int;

  main();

  print foo(2, 3 + 2);
  return;
}

foo := proc(a: int, b: int,) -> int
{
  return a + b;
}
