e := a;
a := b;
b := struct { x: *e };

val00 := 0;

BazBaz := struct
{
  x: int,
  // y: enum { X = x };
};

// TODO: allow to assign constants to enumerators, e.g. "A = 2 + 2".
Baz := enum
{
  A,
  B,
  C,
};

Faz := union
{
  x: [2]int,
  y: *[2]Faz,
  z: *enum { A },
};

Foo := struct
{
  x: int,
  y: bool,
  z: Baz,
};

Bar := struct
{
  foo: Foo,
};

bar := proc(aa: struct { x: int }) -> void
{
  {
    {
      a := b;
      b := 2;
    }
  }

  while true break;
  do continue; while false;

  x: Foo = .{ x = 2, y = false };
  x = .{ x = 2 };
  x.x.foo = 2;
  x.z = .A;

  y: *Foo = &x;
  z: **Foo = null;
  x.* = 42;
  z.  *.*;

  b: [3]int = .{ 3, 4, 5 };
  a: [2][3]int = .{ .{ 0, 1, 2 }, b };
  c: [2]int;
  d := .{ .{ 1, 2, 3 } };
  a[0] = .{ 2, 3, 4 };
  a[0][1] = 42;

  e: bool = cast(2);
  f := cast(bool, 2);

  g := &a[0];      // &[3]int
  h: *[3]int = &g;
  i := &a;         // &[2][3]int

  if false then {} else {}

  val00 = val00 + 42;
  return;
}

FazBaz := struct
{
  x: *[2]FazBaz,
};

foo := proc() -> Foo
{
  // x = .{ x = 2 };
}

main := proc() -> void
{
  val0 := -2 + 2;
  val1: int = 2;
  val2: bool = false;

  switch val0
  {
    0, 1:
    {
      2 + 2;
    }
    2: {}
  }

  val0 = 4;
  val3: proc() = main;
  val3();

  if !true || false && true
    ;
  else
    ;

  val4: int;

  main();

  print foo(2, 3 + 2);
  return;
}

foofaz := proc(a: int, b: int,) -> int
{
  return a + b;

  {
    i := 0;

    {
      {
        j := j + i; // should reject use of variable in its own definition.
      }

      i := 1;
    }
  }
}
