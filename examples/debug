val00 := 0;

aaa: i32 = 0;
aab: i65 = 0;
aac: i6 = 0;

e := a;
a := b;

alias b: struct { x: e^ };

aa: struct { x: int } = _(x = 2);
bb := &aa;
cc := bb^;

alias BazBaz: struct
{
  x: int,
  // y: enum { X = x };
};

// TODO: allow to assign constants to enumerators, e.g. "A = 2 + 2".
alias Baz: enum
{
  A,
  B,
  C,
};

alias Faz: union
{
  x: int[2],
  y: Faz[2]^,
  z: enum { A }^,
};

alias Foo: struct
{
  x: int,
  y: Bar,
  z: Baz,
};

alias Bar: struct
{
  foo: int,
};

bar: proc(aa: struct { x: int }) void
{
  {
    {
      a := if true 2 else 42;
      b := 2;
    }
  }

  while true break;
  do continue; while false;

  x: Foo = _(x = 2, y = _(foo = 2));
  x = _(x = 2);
  x.y.foo = 2;
  x.z = Foo.A;
  f := &x;
  f.x = 42;

  y: Foo^ = &x;
  z: Foo^^ = null;
  z^^;
  y^ = _();

  b: int[3] = _(3, 4, 5);
  a: int[2][3] = _(_( 0, 1, 2), b);
  c: int[2];
  d: int[1][3] = _(_(1, 2, 3));
  a[0] = _(2, 3, 4);
  a[0][1] = 42;

  // e: bool = cast(2);
  // f := cast(bool, 2);

  g := &a[0];      // &[3]int
  h: int[3]^ = &g;
  i := &a;         // &[2][3]int

  if false then {} else {}

  val00 = val00 + 42;
  return;
}

alias FazBaz: struct
{
  x: FazBaz[2]^,
};

foo: proc() Foo
{
  // x = .{ x = 2 };
}

main: proc() void
{
  val0 := -2 + 2;
  val1: int = 2;
  val2: bool = false;

  switch val0
    {
      case 0 then
      case 1
      {
        2 + 2;
      }
      case 2 {}
    }
  else
    {
    }

  val0 = 4;
  val3: proc() void = main;
  val3();

  if !true || false && true
    { }
  else
    { }

  val4: int;
  val5: Faz = _(x = _(4, 2));
  val6: void^ = null;
  val7: void^ = &val6;

  main();

  print foo();
  return;
}

foofaz: proc(a: int, b: int,) int
{
  return a + b;

  {
    i := 0;

    {
      {
        j := i;
      }

      i := 1;
    }
  }
}
