val00: i32 = -1;

aaa: i32 = 0;
aab: u64 = 0;
aac: i6 = 0;
aad: i6 = 0;
aae: i6 = 0;

alias e: a;
alias a: b;
alias b: struct { x: e^ };

aa: struct { x: i64 }; // _(x = 2);
bb := &aa;
cc := bb^;

alias BazBaz: struct
{
  x: i64,
  y: enum { X := 42},
};

// TODO: allow to assign constants to enumerators, e.g. "A = 2 + 2".
alias Baz: enum
{
  A,
  B,
  C,
};

alias Faz: union
{
  x: i64[2],
  y: Faz[2]^,
  z: enum { A }^,
};

alias Foo: struct
{
  x: i64,
  y: Bar,
  z: Baz,
};

alias Bar: struct
{
  foo: i64,
};

bar: proc(aa: struct { x: i64 }) void
{
  {
    {
      a := if true 2 else 42;
      b := 2;
    }
  }

  while true break;
  do continue; while false;

  x: Foo = Foo(x = 2, y = Bar(foo = 2));
  x = Foo(x = 2);
  x.y.foo = 2;
  x.z = Baz.A;
  f := &x;
  f.x = 42;

  y: Foo^ = &x;
  z: Foo^^ = null;
  z^^;
  y^ = Foo();

  b := i32[3](3, 4, 5);
  a: i32[3][2] = i32[3][2](i32[3](0, 1, 2), b);
  c: i32[2];
  d: i32[3][1] = i32[3][1](i32[3](1, 2, 3));
  a[0] = i32[3](2, 3, 4);
  a[0][1] = 42;

  e: bool = cast(bool, 2);
  ff := cast(bool, 2);
  fff: proc() void = null;

  g := &a[0];      // &[3]int
  h: i32[3]^ = &g;
  i := &a;         // &[2][3]int

  if false then {} else {}

  val00 = val00 + 42;
  return;
}

alias FazBaz: struct
{
  x: FazBaz[2]^,
};

foo: proc() Foo
{
  x := Foo(x = 2);
  return x;
}

main: proc() void
{
  val0: i32 = -2 + 2;
  val1: i64 = 2;
  val2: bool = false;

  // switch val0
  //   {
  //     case 0 then
  //     case 1
  //     {
  //       2 + 2;
  //     }
  //     case 2 {}
  //   }
  // else
  //   {
  //   }

  val0 = 4;
  val3: proc() void = main;
  val3();

  if !true || false && true
    { }
  else
    { }

  val4: i64;
  val5: Faz = Faz(x = i64[2](4, 2));
  val6: void^ = null;
  val7: void^ = &val6;

  main();

  // print foo();
  return;
}

foofaz: proc(a: i32, b: i8,) i32
{
  return a + b;

  {
    i := 0;

    {
      {
        j := i;
      }

      i := 1;
    }
  }
}
